import os
import subprocess
import re

# === CONFIGURATION ===
BASE_DIR = "2_problems"
LEVELS = ["easy", "medium", "hard"]
MODEL = "gemma:2b"   # ‚¨ÖÔ∏è Gemma 2B model
TEMPERATURE = 0.2

# === Extract method name from human.py
def extract_method_name(human_code):
    match = re.search(r"def (\w+)\s*\(", human_code)
    return match.group(1) if match else None

# === Wrap output in class Solution
def wrap_in_class(code, method_name):
    lines = code.strip().split("\n")
    if lines[0].strip().startswith("class Solution"):
        return code
    indented = ["    " + line if line.strip() else "" for line in lines]
    return f"class Solution:\n" + "\n".join(indented)

# === Generate code from cleaned_prompt using Ollama
def generate_code(prompt, method_name):
    system_prompt = (
        f"You are an expert competitive programmer. Generate only the Python code that solves the problem, "
        "using the same function name as shown, wrapped inside `class Solution`."
        "Do not output explanations, comments, or alternative languages."
    )
    full_prompt = f"{system_prompt}\n\n{prompt}"

    try:
        result = subprocess.run(
            ["ollama", "run", MODEL],
            input=full_prompt.encode("utf-8"),
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            timeout=240
        )
        output = result.stdout.decode("utf-8")

        # Try to extract code block
        match = re.findall(r"```(?:python)?\s*(.*?)```", output, re.DOTALL)
        code = match[0] if match else output

        # Enforce function name
        code = re.sub(r"def\s+\w+\s*\(", f"def {method_name}(", code, count=1)

        return wrap_in_class(code, method_name)

    except Exception as e:
        return f"# ‚ö†Ô∏è Generation error: {e}"

# === Process all problems ===
for level in LEVELS:
    level_path = os.path.join(BASE_DIR, level)
    if not os.path.isdir(level_path):
        continue

    for dp_folder in sorted(os.listdir(level_path)):
        problem_path = os.path.join(level_path, dp_folder)
        cleaned_prompt_path = os.path.join(problem_path, "cleaned_prompt.txt")
        human_code_path = os.path.join(problem_path, "human.py")
        gemma_code_path = os.path.join(problem_path, "gemma2b.py")

        if not os.path.exists(cleaned_prompt_path) or not os.path.exists(human_code_path):
            print(f"‚ö†Ô∏è Skipping {dp_folder} ‚Äî missing prompt or human.py")
            continue

        with open(cleaned_prompt_path, "r", encoding="utf-8") as f:
            prompt = f.read()

        with open(human_code_path, "r", encoding="utf-8") as f:
            human_code = f.read()

        method_name = extract_method_name(human_code)
        if not method_name:
            print(f"‚ùå Could not extract method name from {dp_folder}")
            continue

        print(f"üöÄ Generating with Gemma 2B for {dp_folder} ‚Üí `{method_name}`")
        solution = generate_code(prompt, method_name)

        with open(gemma_code_path, "w", encoding="utf-8") as f:
            f.write(f"# Generated by Gemma 2B via Ollama\n\n{solution}\n")

        print(f"‚úÖ Saved to {gemma_code_path}")
