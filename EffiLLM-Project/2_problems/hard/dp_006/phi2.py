# Generated by Phi-2 via Ollama

class Solution:
    def dp(n, coins, m):
        # Initialize a list to store the minimum cost at each index
        min_cost = [0] * (n + 1)
        # The first element is 0 because we are already at index 1
        for i in range(2, n + 1):
            # The last element is the current index and 0 because we cannot jump to it
            min_cost[i] = coins[i - 1]
            # If the coin at index i-1 is valid, update the minimum cost by taking the minimum of its previous cost plus one
            if i <= m:
                min_cost[i] = min(min_cost[i], 1 + min_cost[i - coins[i - 1]])
        # Return the minimum cost at index n or an empty array if not possible
        return min_cost[n] * [m] if min_cost[n] == 0 else []
