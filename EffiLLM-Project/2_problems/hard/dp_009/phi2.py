# Generated by Phi-2 via Ollama

class Solution(object):
    def numBeautifulPartitions(self, s, k, minLength):
        """
        :type s: str
        :type k: int
        :type minLength: int
        :rtype: int
        """
        MOD = 10 ** 9 + 7
        # 因为可能有多个单独的节点，所以需要保留k个set中这些节点，并将这些节点和s中元素的intersection作为对应节点的value
        p = [{'1', '2', '3', '5', '7'}]
        for c in s:
            if c.isdigit():
                primes = set()
                for i in range(2, int(c) + 1):
                    if isPrime(i):
                        primes.add(str(i))
                p[-1].intersection_update(primes)
            else:
                p.append({})

        # 在s中抽取的所有子串，并将结果加入到p中
        for i in range(1, len(s) + 1):
            for j in range(i - minLength + 1):
                sub = s[j:i]
                if any((len(primes.intersection(set(sub))) >= 2 and isPrime(int(sub[0]))
                       and not isPrime(int(sub[-1])))) and len(p) > k:
                    for c in range(len(p)):
                        if c == i - 1:
                            p.pop()  # 删除当前节点
                        else:
                            p[c].update(p[i - 1])  # 交并集

        return len(p) % MOD
